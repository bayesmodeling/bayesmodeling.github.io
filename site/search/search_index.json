{
    "docs": [
        {
            "location": "/",
            "text": "What this book all about?\n\n\nAuthor: Al-Ahmadgaid B. Asaad (@alstat - github)\n\n\nTo get started, \nsee the tutorial\n.\n\n\nAlmost everything in Plots is done by specifying plot \nattributes\n.\n$x^2$\nTap into the extensive visualization functionality enabled by the \nPlots ecosystem\n, and easily build your own complex graphics components with \nrecipes\n.\n\n\nIntro to Plots in Julia\n\n\nData visualization has a complicated history.  Plotting software makes trade-offs between features and simplicity, speed and beauty, and a static and dynamic interface. Some packages make a display and never change it, while others make updates in real-time.\n\n\nPlots is a visualization interface and toolset. It sits above other backends, like GR or PyPlot, connecting commands with implementation. If one backend does not support your desired features or make the right trade-offs, you can just switch to another backend with one command. No need to change your code. No need to learn a new syntax. Plots might be the last plotting package you ever learn.\n\n\nMy goals with the package are:\n\n\n\n\nPowerful\n.  Do more with less. Complex visualizations become easy.\n\n\nIntuitive\n.  Start generating plots without reading volumes of documentation. Commands should \"just work.\"\n\n\nConcise\n.  Less code means fewer mistakes and more efficient development and analysis.\n\n\nFlexible\n.  Produce your favorite plots from your favorite package, only quicker and simpler.\n\n\nConsistent\n.  Don't commit to one graphics package. Use the same code and access the strengths of all \nbackends\n.\n\n\nLightweight\n.  Very few dependencies, since backends are loaded and initialized dynamically.\n\n\nSmart\n.  It's not quite AGI, but Plots should figure out what you \nwant\n it to do... not just what you \ntell\n it.\n\n\n\n\nUse the \npreprocessing pipeline\n in Plots to describe your visualization completely before it calls the backend code.  This preprocessing maintains modularity and allows for efficient separation of front end code, algorithms, and backend graphics.\n\n\nPlease add wishlist items, bugs, or any other comments/questions to the \nissues list\n, and \njoin the conversation on gitter\n.\n\n\n\n\nSimple is Beautiful\n\n\nLorenz Attractor\n\n\n# initialize the attractor\nn = 1500\ndt = 0.02\n\u03c3, \u03c1, \u03b2 = 10., 28., 8/3\nx, y, z = 1., 1., 1.\n\n# initialize a 3D plot with 1 empty series\nplt = path3d(1, xlim=(-25,25), ylim=(-25,25), zlim=(0,50),\n                xlab = \"x\", ylab = \"y\", zlab = \"z\",\n                title = \"Lorenz Attractor\", marker = 1)\n\n# build an animated gif, saving every 10th frame\n@gif for i=1:n\n    dx = \u03c3*(y - x)     ; x += dt * dx\n    dy = x*(\u03c1 - z) - y ; y += dt * dy\n    dz = x*y - \u03b2*z     ; z += dt * dz\n    push!(plt, x, y, z)\nend every 10\n\n\n\n\n\n\nMake some waves\n\n\nusing Plots, ProgressMeter\npyplot(leg=false, ticks=nothing)\nx = y = linspace(-5, 5, 40)\nzs = zeros(0,40)\nn = 100\n\n# create a progress bar for tracking the animation generation\nprog = Progress(n,1)\n\n@gif for i in linspace(0, 2\u03c0, n)\n    f(x,y) = sin(x + 10sin(i)) + cos(y)\n\n    # create a plot with 3 subplots and a custom layout\n    l = @layout [a{0.7w} b; c{0.2h}]\n    p = plot(x, y, f, st = [:surface, :contourf], layout=l)\n\n    # induce a slight oscillating camera angle sweep, in degrees (azimuth, altitude)\n    plot!(p[1],camera=(15*cos(i),40))\n\n    # add a tracking line\n    fixed_x = zeros(40)\n    z = map(f,fixed_x,y)\n    plot!(p[1], fixed_x, y, z, line = (:black, 5, 0.2))\n    vline!(p[2], [0], line = (:black, 5))\n\n    # add to and show the tracked values over time\n    zs = vcat(zs, z')\n    plot!(p[3], zs, alpha = 0.2, palette = cgrad(:blues).colors)\n\n    # increment the progress bar\n    next!(prog)\nend\n\n\n\n\n\n\nIris Dataset\n\n\n# load a dataset\nusing RDatasets\niris = dataset(\"datasets\", \"iris\");\n\n# load the StatPlots recipes (for DataFrames) available via:\n# Pkg.add(\"StatPlots\")\nusing StatPlots\n\n# Scatter plot with some custom settings\n@df iris scatter(:SepalLength, :SepalWidth, group=:Species,\n        title = \"My awesome plot\",\n        xlabel = \"Length\", ylabel = \"Width\",\n        m=(0.5, [:cross :hex :star7], 12),\n        bg=RGB(.2,.2,.2))\n\n# save a png\npng(\"iris\")",
            "title": "What this book all about?"
        },
        {
            "location": "/#what-this-book-all-about",
            "text": "Author: Al-Ahmadgaid B. Asaad (@alstat - github)  To get started,  see the tutorial .  Almost everything in Plots is done by specifying plot  attributes .\n$x^2$\nTap into the extensive visualization functionality enabled by the  Plots ecosystem , and easily build your own complex graphics components with  recipes .",
            "title": "What this book all about?"
        },
        {
            "location": "/#intro-to-plots-in-julia",
            "text": "Data visualization has a complicated history.  Plotting software makes trade-offs between features and simplicity, speed and beauty, and a static and dynamic interface. Some packages make a display and never change it, while others make updates in real-time.  Plots is a visualization interface and toolset. It sits above other backends, like GR or PyPlot, connecting commands with implementation. If one backend does not support your desired features or make the right trade-offs, you can just switch to another backend with one command. No need to change your code. No need to learn a new syntax. Plots might be the last plotting package you ever learn.  My goals with the package are:   Powerful .  Do more with less. Complex visualizations become easy.  Intuitive .  Start generating plots without reading volumes of documentation. Commands should \"just work.\"  Concise .  Less code means fewer mistakes and more efficient development and analysis.  Flexible .  Produce your favorite plots from your favorite package, only quicker and simpler.  Consistent .  Don't commit to one graphics package. Use the same code and access the strengths of all  backends .  Lightweight .  Very few dependencies, since backends are loaded and initialized dynamically.  Smart .  It's not quite AGI, but Plots should figure out what you  want  it to do... not just what you  tell  it.   Use the  preprocessing pipeline  in Plots to describe your visualization completely before it calls the backend code.  This preprocessing maintains modularity and allows for efficient separation of front end code, algorithms, and backend graphics.  Please add wishlist items, bugs, or any other comments/questions to the  issues list , and  join the conversation on gitter .",
            "title": "Intro to Plots in Julia"
        },
        {
            "location": "/#simple-is-beautiful",
            "text": "Lorenz Attractor  # initialize the attractor\nn = 1500\ndt = 0.02\n\u03c3, \u03c1, \u03b2 = 10., 28., 8/3\nx, y, z = 1., 1., 1.\n\n# initialize a 3D plot with 1 empty series\nplt = path3d(1, xlim=(-25,25), ylim=(-25,25), zlim=(0,50),\n                xlab = \"x\", ylab = \"y\", zlab = \"z\",\n                title = \"Lorenz Attractor\", marker = 1)\n\n# build an animated gif, saving every 10th frame\n@gif for i=1:n\n    dx = \u03c3*(y - x)     ; x += dt * dx\n    dy = x*(\u03c1 - z) - y ; y += dt * dy\n    dz = x*y - \u03b2*z     ; z += dt * dz\n    push!(plt, x, y, z)\nend every 10   Make some waves  using Plots, ProgressMeter\npyplot(leg=false, ticks=nothing)\nx = y = linspace(-5, 5, 40)\nzs = zeros(0,40)\nn = 100\n\n# create a progress bar for tracking the animation generation\nprog = Progress(n,1)\n\n@gif for i in linspace(0, 2\u03c0, n)\n    f(x,y) = sin(x + 10sin(i)) + cos(y)\n\n    # create a plot with 3 subplots and a custom layout\n    l = @layout [a{0.7w} b; c{0.2h}]\n    p = plot(x, y, f, st = [:surface, :contourf], layout=l)\n\n    # induce a slight oscillating camera angle sweep, in degrees (azimuth, altitude)\n    plot!(p[1],camera=(15*cos(i),40))\n\n    # add a tracking line\n    fixed_x = zeros(40)\n    z = map(f,fixed_x,y)\n    plot!(p[1], fixed_x, y, z, line = (:black, 5, 0.2))\n    vline!(p[2], [0], line = (:black, 5))\n\n    # add to and show the tracked values over time\n    zs = vcat(zs, z')\n    plot!(p[3], zs, alpha = 0.2, palette = cgrad(:blues).colors)\n\n    # increment the progress bar\n    next!(prog)\nend   Iris Dataset  # load a dataset\nusing RDatasets\niris = dataset(\"datasets\", \"iris\");\n\n# load the StatPlots recipes (for DataFrames) available via:\n# Pkg.add(\"StatPlots\")\nusing StatPlots\n\n# Scatter plot with some custom settings\n@df iris scatter(:SepalLength, :SepalWidth, group=:Species,\n        title = \"My awesome plot\",\n        xlabel = \"Length\", ylabel = \"Width\",\n        m=(0.5, [:cross :hex :star7], 12),\n        bg=RGB(.2,.2,.2))\n\n# save a png\npng(\"iris\")",
            "title": "Simple is Beautiful"
        },
        {
            "location": "/README/",
            "text": "bayesmodeling.github.io",
            "title": "bayesmodeling.github.io"
        },
        {
            "location": "/README/#bayesmodelinggithubio",
            "text": "",
            "title": "bayesmodeling.github.io"
        }
    ]
}